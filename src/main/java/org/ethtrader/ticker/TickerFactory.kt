package org.ethtrader.ticker

import com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES
import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import java.awt.*
import java.awt.RenderingHints.VALUE_ANTIALIAS_ON
import java.awt.image.BufferedImage
import java.awt.image.BufferedImage.TYPE_INT_ARGB
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.InputStream
import java.math.BigDecimal
import java.math.BigDecimal.ZERO
import java.math.RoundingMode.HALF_DOWN
import java.net.URL
import java.util.Locale.ENGLISH
import javax.imageio.ImageIO

data class DataPointDef(
        val dataPointName: String,
        val valueName: String,
        val prefix: String,
        val suffix: String,
        val precision: String,
        val useColor: String,
        val shorten: String,
        val divisor: String,
        val highlight: Boolean,
        val fxName: String?,
        val fxValue: String?,
        val image: String?)

data class DataPoint(
        val text: String,
        val color: Color,
        val highlight: Boolean,
        val width: Int,
        val image: BufferedImage? = null)

class TickerFactory(private val outputDir: File, private val loadResource: (String) -> URL) {

    val apiStart = "/** Generated by ticker bot [start of section] */"
    val apiEnd = "/** Generated by ticker bot [end of section] */"
    val objectMapper = ObjectMapper().registerKotlinModule().enable(ALLOW_UNQUOTED_FIELD_NAMES)

    private val css = StringBuilder()

    init {
        System.setProperty("java.awt.headless", "true")
        resetCss()
    }

    fun produceTicker(name: String, data: Map<String, Map<String, BigDecimal?>?>, config: TickerConf): InputStream {

        val font = Font(config.font, Font.BOLD, config.fontHeight)
        val graphics: Graphics = BufferedImage(1, 1, TYPE_INT_ARGB).graphics.fluently { it.font = font }

        val images = config.segments.flatMap {
            try {
                produceTickerSegment(data, config, it, graphics.fontMetrics)
            } catch (e: Exception) {
                System.err.println(e.message)
                e.printStackTrace()
                emptyList<BufferedImage>()
            }
        }.filterNotNull()
        val image = combineImages(images)
        val file = File(outputDir, "$name.png")
        ImageIO.write(image, "png", file)
        println("Ticker [$name] saved to [${file.absolutePath}]")
        addCss(name, config, image)
        return getInputStream(image)
    }

    private fun loadImage(config: TickerConf, location: String, highlight: Boolean): BufferedImage {
        val image = ImageIO.read(loadResource(location))
        val padding = 8
        val width = image.width + padding * 2
        val imageWithBackground = BufferedImage(width, image.height, TYPE_INT_ARGB)
        (imageWithBackground.graphics as Graphics2D)
                .fluently { it.color = if (highlight) config.backgroundHighlight else config.background }
                .fluently { it.fillRect(0, 0, width, image.height) }
                .fluently { it.drawImage(image, padding, 0, null) }
        return imageWithBackground
    }

    private fun addCss(name: String, conf: TickerConf, image: BufferedImage) {
        val template = loadResource("/per-ticker.css").readText(Charsets.UTF_8)
                .replace("\${ticker.name}", name)
                .replace("\${ticker.width}", image.width.toString())
                .replace("\${ticker.top}", conf.top)
                .replace("\${css.selector}", conf.cssSelector)
        css.append("$template\n\n")
    }

    private fun combineImages(images: List<BufferedImage>): BufferedImage {
        var cumulative = 0
        val image = BufferedImage(images.sumBy { it.width }, images.first().height, TYPE_INT_ARGB)
        val graphics = image.graphics
        images.forEach { image ->
            graphics.drawImage(image, cumulative, 0, null)
            cumulative += image.width
        }
        return image
    }

    private fun produceTickerSegment(data: Map<String, Map<String, BigDecimal?>?>, config: TickerConf, it: String, fontMetrics: FontMetrics): List<BufferedImage> {
        val segments = parseSegments(data, config, it, fontMetrics)
        return render(config, segments, fontMetrics)
    }

    private fun parseSegments(data: Map<String, Map<String, BigDecimal?>?>, config: TickerConf, it: String, fontMetrics: FontMetrics): DataPoint {
        try {
            val dataPoint = objectMapper.readValue<DataPointDef>(it)
            return format(data, dataPoint, config, fontMetrics)
        } catch(e: JsonProcessingException) {
            return DataPoint(it, config.color, false, fontMetrics.stringWidth(it))
        }
    }

    private fun render(config: TickerConf, segment: DataPoint, fontMetrics: FontMetrics): List<BufferedImage> {
        val image = BufferedImage(segment.width, fontMetrics.height + 4, TYPE_INT_ARGB)
        val graphics = image.graphics as Graphics2D
        val highlight = segment.text.startsWith("!") || segment.highlight
        graphics.fluently { it.setRenderingHint(RenderingHints.KEY_ANTIALIASING, VALUE_ANTIALIAS_ON) }
                .fluently { it.color = if (highlight) config.backgroundHighlight else config.background }

        var x = 0
        val weight = if (true) Font.BOLD else Font.PLAIN
        graphics.fluently { it.color = if (highlight) config.backgroundHighlight else config.background }
                .fluently { it.fillRect(x, 0, segment.width, image.height) }
                .fluently { it.color = segment.color }
                .fluently { it.font = Font(config.font, weight, config.fontHeight) }
                .fluently { it.drawString(segment.text.trimStart('!'), x, fontMetrics.ascent + 2) }
        x += segment.width
        return if (segment.image != null) listOf(segment.image, image) else listOf(image)
    }

    private fun format(data: Map<String, Map<String, BigDecimal?>?>, dataPoint: DataPointDef, config: TickerConf, fontMetrics: FontMetrics): DataPoint {
        return dataPoint.dataPointName.split('^').map { dataPointName ->
            val value = data[dataPointName]?.get(dataPoint.valueName)?.divide(BigDecimal(dataPoint.divisor))
            val fxValue = if (dataPoint.fxName != null && dataPoint.fxValue != null) data[dataPoint.fxName]?.get(dataPoint.fxValue) else null
            if (value == null) {
                null
            } else {
                val valueAfterFx = if (fxValue != null) value * fxValue else value
                val color = if (dataPoint.useColor == "Y") if (valueAfterFx >= ZERO) config.positiveColor else config.negativeColor else config.color
                val adjustedPrecision = valueAfterFx.setScale(dataPoint.precision.toInt(), HALF_DOWN)
                val shortenedValue = if (dataPoint.shorten == "Y") shorten(adjustedPrecision, "", "k", "M", "B", "T") else String.format(ENGLISH, "%,.${dataPoint.precision}f", adjustedPrecision)

                val text = "${dataPoint.prefix}$shortenedValue${dataPoint.suffix}"
                DataPoint(text, color, dataPoint.highlight, fontMetrics.stringWidth(text), dataPoint.image?.let { loadImage(config, it, dataPoint.highlight) })
            }
        }.filterNotNull().firstOrNull() ?: throw RuntimeException("ERROR - No value [${dataPoint.valueName}] or no data point [${dataPoint.dataPointName}] in [$data]")
    }

    private val OneThousand = BigDecimal("1000")
    private val TenThousand = BigDecimal("10000")

    private fun shorten(value: BigDecimal, vararg denomiators: String): String {
        return if (value < TenThousand) value.toPlainString() + denomiators.first()
        else shorten(value / OneThousand, *denomiators.drop(1).toTypedArray())
    }

    private fun getInputStream(upper: BufferedImage): InputStream {
        val byteArrayOutputStream = ByteArrayOutputStream()
        ImageIO.write(upper, "png", byteArrayOutputStream)
        return ByteArrayInputStream(byteArrayOutputStream.toByteArray())
    }

    fun <T> T.fluently(action: (T) -> Unit): T {
        action(this)
        return this
    }

    fun getAndResetCss(existing: String): String {
        val existingLines = existing.lines()
        val newLines = css.lines()
        resetCss()
        return (existingLines.takeWhile { !it.equals(apiStart) } +
                "$apiStart\n\n" +
                newLines +
                if (existingLines.contains(apiEnd)) existingLines.dropWhile { !it.equals(apiEnd) } else listOf(apiEnd)).joinToString(System.lineSeparator())
    }

    private fun resetCss() {
        css.setLength(0)
        css.append(loadResource("/ticker.css").readText(Charsets.UTF_8)).append("\n\n")
    }
}

operator fun <E> List<E>.component6(): Any = get(5)!!
operator fun <E> List<E>.component7(): Any = get(6)!!
operator fun <E> List<E>.component8(): Any = get(7)!!
