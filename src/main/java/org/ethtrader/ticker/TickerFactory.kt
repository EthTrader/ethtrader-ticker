package org.ethtrader.ticker

import java.awt.*
import java.awt.RenderingHints.VALUE_ANTIALIAS_ON
import java.awt.image.BufferedImage
import java.awt.image.BufferedImage.TYPE_INT_ARGB
import java.io.*
import java.math.BigDecimal
import java.math.BigDecimal.ZERO
import java.math.RoundingMode.HALF_DOWN
import java.net.URL
import java.util.Locale.ENGLISH
import javax.imageio.ImageIO

class TickerFactory(private val outputDir: File, private val loadResource: (String) -> URL) {

    val apiStart = "/** Generated by ticker bot [start of section] */"
    val apiEnd = "/** Generated by ticker bot [end of section] */"

    private val css = StringBuilder()

    init {
        System.setProperty("java.awt.headless", "true")
        resetCss()
    }

    fun produceTicker(name: String, data: Map<String, Map<String, BigDecimal?>?>, config: TickerConf): InputStream {

        val font = Font(config.font, Font.BOLD, config.fontHeight)
        val graphics: Graphics = BufferedImage(1, 1, TYPE_INT_ARGB).graphics.fluently { it.font = font }

        val images = config.segments.map {
            try {
                if (it.startsWith("[[") && it.endsWith("]]")) {
                    loadImage(config, it.substring(2, it.length - 2))
                } else {
                    produceTickerSegment(data, config, it, graphics.fontMetrics)
                }
            } catch (e: Exception) {
                System.err.println(e.message)
                e.printStackTrace()
                null
            }
        }.filterNotNull()
        val image = combineImages(images, config)
        val file = File(outputDir, "$name.png")
        ImageIO.write(image, "png", file)
        println("Ticker [$name] saved to [${file.absolutePath}]")
        addCss(name, config, image)
        return getInputStream(image)
    }

    private fun loadImage(config: TickerConf, location: String): BufferedImage {
        val image = ImageIO.read(loadResource(location.trimStart('!')))
        val imageWithBackground = BufferedImage(image.width, image.height, TYPE_INT_ARGB)
        val bold = location.startsWith("!")
        (imageWithBackground.graphics as Graphics2D)
                .fluently { it.color = if (bold) config.backgroundHighlight else config.background }
                .fluently { it.fillRect(0, 0, image.width, image.height) }
                .fluently { it.drawImage(image, 0, 0, null) }
                .fluently { it.drawImage(image, 0, 0, null) }
                .fluently { it.drawImage(image, 0, 0, null) }
                .fluently { it.drawImage(image, 0, 0, null) }
        return imageWithBackground
    }

    private fun addCss(name: String, conf: TickerConf, image: BufferedImage) {
        val template = loadResource("/per-ticker.css").readText(Charsets.UTF_8)
                .replace("\${ticker.name}", name)
                .replace("\${ticker.width}", image.width.toString())
                .replace("\${ticker.top}", conf.top)
                .replace("\${css.selector}", conf.cssSelector)
        css.append("$template\n\n")
    }

    private fun combineImages(images: List<BufferedImage>, tickerConf: TickerConf): BufferedImage {
        var cumulative = 0
        val image = BufferedImage(images.sumBy { it.width }, images.first().height, TYPE_INT_ARGB)
        val graphics = image.graphics
        images.forEach { image ->
            graphics.drawImage(image, cumulative, 0, null)
            cumulative += image.width
        }
        return image
    }

    private fun produceTickerSegment(data: Map<String, Map<String, BigDecimal?>?>, config: TickerConf, it: String, fontMetrics: FontMetrics): BufferedImage {
        val segments = parseSegments(data, config, it, fontMetrics)
        return render(config, segments, fontMetrics)
    }

    private fun parseSegments(data: Map<String, Map<String, BigDecimal?>?>, config: TickerConf, it: String, fontMetrics: FontMetrics): List<Triple<String, Color, Int>> {
        return it.split(Regex("[\\{\\}]")).map { match ->
            val tokens = match.trim('{', '}').split('|', '.')
            if (tokens.size == 8) format(data, tokens, config) else match to config.color
        }.map { Triple(it.first, it.second, fontMetrics.stringWidth(it.first)) }
    }

    private fun render(config: TickerConf, segments: List<Triple<String, Color, Int>>, fontMetrics: FontMetrics): BufferedImage {
        val image = BufferedImage(segments.sumBy { it.third }, fontMetrics.height + 4, TYPE_INT_ARGB)
        val graphics = image.graphics as Graphics2D
        val bold = segments.first().first.startsWith("!")
        graphics.fluently { it.setRenderingHint(RenderingHints.KEY_ANTIALIASING, VALUE_ANTIALIAS_ON) }
                .fluently { it.color = if (bold) config.backgroundHighlight else config.background }

        var x = 0
        val weight = if (true) Font.BOLD else Font.PLAIN
        segments.forEach { segment ->
            graphics.fluently { it.color = if (bold) config.backgroundHighlight else config.background }
                    .fluently { it.fillRect(x, 0, segment.third, image.height) }
                    .fluently { it.color = segment.second }
                    .fluently { it.font = Font(config.font, weight, config.fontHeight) }
                    .fluently { it.drawString(segment.first.trimStart('!'), x, fontMetrics.ascent + 2) }
            x += segment.third
        }
        return image
    }

    private fun format(data: Map<String, Map<String, BigDecimal?>?>, tokens: List<String>, config: TickerConf): Pair<String, Color> {
        val (dataPointNames, valueName, prefix, suffix, precision, useColor, shorten, divisor) = tokens
        return dataPointNames.split('^').map { dataPointName ->
            val value = data[dataPointName]?.get(valueName)?.divide(BigDecimal(divisor.toString()))
            if (value == null) {
                null
            } else {
                val color = if (useColor == "Y") if (value.compareTo(ZERO) >= 0) config.positiveColor else config.negativeColor else config.color
                val adjustedPrecision = value.setScale(precision.toInt(), HALF_DOWN)
                val shortenedValue = if (shorten == "Y") shorten(adjustedPrecision, "", "k", "M", "B", "T") else String.format(ENGLISH, "%,.${precision}f", adjustedPrecision)

                ("$prefix$shortenedValue$suffix") to color
            }
        }.filterNotNull().firstOrNull() ?: throw RuntimeException("ERROR - No value [$valueName] or no data point [$dataPointNames] in [$data]")
    }

    private val OneThousand = BigDecimal("1000")
    private val TenThousand = BigDecimal("10000")

    private fun shorten(value: BigDecimal, vararg denomiators: String): String {
        return if (value < TenThousand) value.toPlainString() + denomiators.first()
        else shorten(value / OneThousand, *denomiators.drop(1).toTypedArray())
    }

    private fun getInputStream(upper: BufferedImage): InputStream {
        val byteArrayOutputStream = ByteArrayOutputStream()
        ImageIO.write(upper, "png", byteArrayOutputStream)
        return ByteArrayInputStream(byteArrayOutputStream.toByteArray())
    }

    fun <T> T.fluently(action: (T) -> Unit): T {
        action(this)
        return this
    }

    fun getAndResetCss(existing: String): String {
        val existingLines = existing.lines()
        val newLines = css.lines()
        resetCss()
        return (existingLines.takeWhile { !it.equals(apiStart) } +
                "$apiStart\n\n" +
                newLines +
                if (existingLines.contains(apiEnd)) existingLines.dropWhile { !it.equals(apiEnd) } else listOf(apiEnd)).joinToString(System.lineSeparator())
    }

    private fun resetCss() {
        css.setLength(0)
        css.append(loadResource("/ticker.css").readText(Charsets.UTF_8)).append("\n\n")
    }
}

operator fun <E> List<E>.component6(): Any = get(5)!!
operator fun <E> List<E>.component7(): Any = get(6)!!
operator fun <E> List<E>.component8(): Any = get(7)!!
